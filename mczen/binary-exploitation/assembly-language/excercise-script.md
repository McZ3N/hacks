# Excercise Script

<figure><img src="broken-reference" alt=""><figcaption></figcaption></figure>

We are going to make a Fibonacci calculator. Fibonacci is simpley 1 + 1 = 2, then take last numbers and add to 1 + 2 = 3. The program will take an input of max number.

We start with data movement by setting 0 to `rax` and 1 to `rxb`.

```nasm
global  _start    ; Tell assembler to make entry point _start visible to linker.

section .text     ; .text is where code and instructions go.
_start:
    mov rax, 0    ; Put 0 value into rax
    mov rbx, 1    ; Put 1 value into rbx
```

As 1 would be 0x00000001 in 64 bit, its not efficient so we use 1 byte register `bl`.

```nasm
global  _start

section .text
_start:
    mov al, 0
    mov bl, 1
```

### <mark style="color:yellow;">Address Pointers</mark>

Pointer registers do not contain values but the point to another address that holds the value. For example if we would `mov rax, rsp` as rsp is the current stack pointer. We are not moving the value but move the pointer address to `rax`.

{% hint style="info" %}
To move the value we use brackets like

```nasm
mov rax, rsp    ; copies address in rsp to rax
mov rax, [rsp]  ; copies value stored at address that rsp point to into rax.
```
{% endhint %}

### <mark style="color:yellow;">**Loading Value Pointers**</mark>

Using `lea` or Load Effective Address we load a pointer to a specific value like: `lea rax, [rsp]`. This is the opposite from above where we load pointer to a value and here we move value from pointer, it loads the address not the value.

```nasm
global  _start

section .text
_start:
    lea rax, [rsp+10]
    mov rax, [rsp+10]
```

{% hint style="info" %}
`lea rax, [rsp+10]` loaded the address that is 10 addresses away from `rsp` so 10 addresses away from top of stack moving the value stored there to rax.
{% endhint %}

### <mark style="color:yellow;">Arithmetic Instructions</mark>

Assuming rax starts at 1 for each instruction.

<table><thead><tr><th width="107">Instruction</th><th width="161">Description</th><th>Example</th></tr></thead><tbody><tr><td><code>inc</code></td><td>Increment by 1</td><td><code>inc rax</code> -> <code>rax++</code> or <code>rax += 1</code> -> <code>rax = 2</code></td></tr><tr><td><code>dec</code></td><td>Decrement by 1</td><td><code>dec rax</code> -> <code>rax--</code> or <code>rax -= 1</code> -> <code>rax = 0</code></td></tr></tbody></table>

Now lets increment the value of `bl` with 1.

```nasm
global  _start
section .text
_start:
    mov al, 0    ; al more efficent than rax, set value 0
    mov bl, 0    ; set value at 0 
    inc bl       ; increment with 1
```

### <mark style="color:yellow;">Binary Instructions</mark>

<table><thead><tr><th width="112">Instruction</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td><code>add</code></td><td>Add both operands</td><td><code>add rax, rbx</code> -> <code>rax = 1 + 1</code> -> <code>2</code></td></tr><tr><td><code>sub</code></td><td>Subtract Source from Destination (<em>i.e <code>rax = rax - rbx</code></em>)</td><td><code>sub rax, rbx</code> -> <code>rax = 1 - 1</code> -> <code>0</code></td></tr><tr><td><code>imul</code></td><td>Multiply both operands</td><td><code>imul rax, rbx</code> -> <code>rax = 1 * 1</code> -> <code>1</code></td></tr></tbody></table>

```nasm
global  _start

section .text
_start:
   mov al, 0      
   mov bl, 0
   inc bl            ; we increment with 1
   add rax, rbx      ; rax is equal to 0x1 + 0x0. rax = rax + rbx
```

### <mark style="color:yellow;">Bitwise Intstructions</mark>

<table><thead><tr><th width="120">Instruction</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td><code>not</code></td><td>Bitwise NOT (invert all bits, 0->1 and 1->0)</td><td><code>not rax</code> -> <code>NOT 00000001</code> -> <code>11111110</code></td></tr><tr><td><code>and</code></td><td>Bitwise AND (if both bits are 1 -> 1, if bits are different -> 0)</td><td><code>and rax, rbx</code> -> <code>00000001 AND 00000010</code> -> <code>00000000</code></td></tr><tr><td><code>or</code></td><td>Bitwise OR (if either bit is 1 -> 1, if both are 0 -> 0)</td><td><code>or rax, rbx</code> -> <code>00000001 OR 00000010</code> -> <code>00000011</code></td></tr><tr><td><code>xor</code></td><td>Bitwise XOR (if bits are the same -> 0, if bits are different -> 1)</td><td><code>xor rax, rbx</code> -> <code>00000001 XOR 00000010</code> -> <code>00000011</code></td></tr></tbody></table>

We can uss `xor` to torn any value to 0 by `xor`ing a value with itself. So if `rax` would 8888, you `xor` it with itself which is 8888 and thus is 0.

```nasm
global  _start

section .text
_start:
    xor rax, rax  ; better than mov al, 0
    xor rbx, rbx  ; better than mov bl, 0
    inc rbx
    add rax, rbx
```

### <mark style="color:yellow;">Loop Structure</mark>

<table><thead><tr><th width="131">Instruction</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td>mov rcx, x</td><td>Sets loop (<code>rcx</code>) counter to <code>x</code></td><td>mov rcx, 3</td></tr><tr><td>loop</td><td>Jumps back to the start of <code>loop</code> until counter reaches <code>0</code></td><td>loop exampleLoop</td></tr></tbody></table>

```nasm
global  _start

section .text
_start:
    xor rax, rax    ; initialize rax to 0
    xor rbx, rbx    ; initialize rbx to 0
    inc rbx         ; increment rbx to 1
    mov rcx, 10     ; 10 iterations
loopFib:
    add rax, rbx    ; get the next number
    xchg rax, rbx   ; swap values
    loop loopFib
```

### <mark style="color:yellow;">Unconditional Branching</mark>

`jump` will allow us to `jump` to any point in the program if a condition is met. After that it will continue processing instructions from that point. The basic `jmp` will always jump to the specified location, regardless of conditions.

### <mark style="color:yellow;">Conditional Branching</mark>

Conditional Branching instructions are only processed when a specific condition is meet.

```nasm
jz   D = 0     ; Destination equal to Zero
jnz  D != 0    ; Destination Not equal to Zero
```

For all conditions: [https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf#page=585](https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf#page=585)

### <mark style="color:yellow;">CMP</mark>

The compare instruction compares 2 operands, by subtracting the 2nd operand from the first. So after the first Fibonacci number is calculated it will 1 - 10 = -9 and as its negative it will jump, once it hits positve number it will not jump.

```nasm
global  _start

section .text
_start:
    xor rax, rax    ; initialize rax to 0
    xor rbx, rbx    ; initialize rbx to 0
    inc rbx         ; increment rbx to 1
loopFib:
    add rax, rbx    ; get the next number
    xchg rax, rbx   ; swap values
    cmp rbx, 10		; do rbx - 10
    js loopFib		; jump if result is <0
```

### <mark style="color:yellow;">PUSH/POP</mark>

To preserve our registers and values we can `push` it to the stack and get them back after syscall using `pop`.

```nasm
global  _start

section .text
_start:
    xor rax, rax    ; initialize rax to 0
    xor rbx, rbx    ; initialize rbx to 0
    inc rbx         ; increment rbx to 1
    push rax        ; push registers to stack
    push rbx
    ; call function
    pop rbx         ; restore registers from stack
    pop rax
```

### <mark style="color:yellow;">Syscalls</mark>

Syscall is function written in C, like <mark style="color:blue;">read</mark> or <mark style="color:blue;">write</mark>. The `write` syscall has number 1 so `mov rax, 1` . However write requires arguments.

1. `rdi` -> `1` (for stdout)
2. `rsi` -> `'Fibonacci Sequence:\n'` (pointer to our string)
3. `rdx` -> `20` (length of our string)

As the string is longer than 16 chars - 64 bits we need a variable. Message label is the pointer to where our strings is stored in memory. <mark style="color:red;">Below will not work yet</mark>.

```nasm
global  _start

section .data
    message db "Fibonacci Sequence:", 0x0a
    
    mov rax, 1       ; rax: syscall number 1
    mov rdi, 1       ; rdi: fd 1 for stdout
    mov rsi,message  ; rsi: pointer to message
    mov rdx, 20      ; rdx: print length of 20 bytes
syscall              ; call write syscall intro message
    xor rbx, rbx     ; initialize rbx to 0
    inc rbx          ; increment rbx to 1
loopFib:
    add rax, rbx     ; get the next number
    xchg rax, rbx    ; swap values
    cmp rbx, 10	     ; do rbx - 10
    js loopFib	     ; jump if result is <0
    mov rax, 60
    mov rdi, 0
    syscall
```

### <mark style="color:yellow;">Procedures</mark>

A `procedure` (sometimes referred to as a `subroutine`) is usually a set of instructions we want to execute at specific points in the program. Using `ret` we return to the point where we were before jumping tot the procedure.

<table><thead><tr><th width="124">Instruction</th><th width="438">Description</th><th>Example</th></tr></thead><tbody><tr><td><code>call</code></td><td>push the next instruction pointer <code>rip</code> to the stack, then jumps to the specified procedure</td><td><code>call printMessage</code></td></tr><tr><td><code>ret</code></td><td>pop the address at <code>rsp</code> into <code>rip</code>, then jump to it</td><td><code>ret</code></td></tr></tbody></table>

```nasm
global  _start

section .data
    message db "Fibonacci Sequence:", 0x0a

section .text
_start:
    call printMessage   ; print intro message
    call initFib        ; set initial Fib values
    call loopFib        ; calculate Fib numbers
    call Exit           ; Exit the program

printMessage:
    mov rax, 1       ; rax: syscall number 1
    mov rdi, 1       ; rdi: fd 1 for stdout
    mov rsi,message  ; rsi: pointer to message
    mov rdx, 20      ; rdx: print length of 20 bytes
    syscall          ; call write syscall to the intro message
    ret
    
initFib:
    xor rax, rax     ; initialize rax to 0
    xor rbx, rbx     ; initialize rbx to 0
    inc rbx          ; increment rbx to 1
    ret
    
loopFib:
    add rax, rbx     ; get the next number
    xchg rax, rbx    ; swap values
    cmp rbx, 10	     ; do rbx - 10
    js loopFib	     ; jump if result is <0
    ret
    
Exit:
    mov rax, 60      ; 60 is syscall nr for exit
    mov rdi, 0
    syscall
```
